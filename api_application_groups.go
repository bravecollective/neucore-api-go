/*
Neucore API

Client library of Neucore API

API version: 1.36.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package neucoreapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ApplicationGroupsApiService ApplicationGroupsApi service
type ApplicationGroupsApiService service

type ApiAllianceGroupsBulkV1Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	requestBody *[]int32
}

// EVE alliance IDs array.
func (r ApiAllianceGroupsBulkV1Request) RequestBody(requestBody []int32) ApiAllianceGroupsBulkV1Request {
	r.requestBody = &requestBody
	return r
}

func (r ApiAllianceGroupsBulkV1Request) Execute() ([]Alliance, *http.Response, error) {
	return r.ApiService.AllianceGroupsBulkV1Execute(r)
}

/*
AllianceGroupsBulkV1 Return groups of multiple alliances.

Needs role: app-groups.<br>
     *                  Returns only groups that have been added to the app as well.
     *                  Skips alliances that are not found in the local database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAllianceGroupsBulkV1Request
*/
func (a *ApplicationGroupsApiService) AllianceGroupsBulkV1(ctx context.Context) ApiAllianceGroupsBulkV1Request {
	return ApiAllianceGroupsBulkV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Alliance
func (a *ApplicationGroupsApiService) AllianceGroupsBulkV1Execute(r ApiAllianceGroupsBulkV1Request) ([]Alliance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Alliance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.AllianceGroupsBulkV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v1/alliance-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAllianceGroupsV1Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	aid int32
}

func (r ApiAllianceGroupsV1Request) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.AllianceGroupsV1Execute(r)
}

/*
AllianceGroupsV1 Return groups of the alliance.

Needs role: app-groups.<br>Returns only groups that have been added to the app as well.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aid EVE alliance ID.
 @return ApiAllianceGroupsV1Request

Deprecated
*/
func (a *ApplicationGroupsApiService) AllianceGroupsV1(ctx context.Context, aid int32) ApiAllianceGroupsV1Request {
	return ApiAllianceGroupsV1Request{
		ApiService: a,
		ctx: ctx,
		aid: aid,
	}
}

// Execute executes the request
//  @return []Group
// Deprecated
func (a *ApplicationGroupsApiService) AllianceGroupsV1Execute(r ApiAllianceGroupsV1Request) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.AllianceGroupsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v1/alliance-groups/{aid}"
	localVarPath = strings.Replace(localVarPath, "{"+"aid"+"}", url.PathEscape(parameterToString(r.aid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAllianceGroupsV2Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	aid int32
}

func (r ApiAllianceGroupsV2Request) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.AllianceGroupsV2Execute(r)
}

/*
AllianceGroupsV2 Return groups of the alliance.

Needs role: app-groups.<br>Returns only groups that have been added to the app as well.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param aid EVE alliance ID.
 @return ApiAllianceGroupsV2Request
*/
func (a *ApplicationGroupsApiService) AllianceGroupsV2(ctx context.Context, aid int32) ApiAllianceGroupsV2Request {
	return ApiAllianceGroupsV2Request{
		ApiService: a,
		ctx: ctx,
		aid: aid,
	}
}

// Execute executes the request
//  @return []Group
func (a *ApplicationGroupsApiService) AllianceGroupsV2Execute(r ApiAllianceGroupsV2Request) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.AllianceGroupsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v2/alliance-groups/{aid}"
	localVarPath = strings.Replace(localVarPath, "{"+"aid"+"}", url.PathEscape(parameterToString(r.aid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCorpGroupsBulkV1Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	requestBody *[]int32
}

// EVE corporation IDs array.
func (r ApiCorpGroupsBulkV1Request) RequestBody(requestBody []int32) ApiCorpGroupsBulkV1Request {
	r.requestBody = &requestBody
	return r
}

func (r ApiCorpGroupsBulkV1Request) Execute() ([]Corporation, *http.Response, error) {
	return r.ApiService.CorpGroupsBulkV1Execute(r)
}

/*
CorpGroupsBulkV1 Return groups of multiple corporations.

Needs role: app-groups.<br>
     *                  Returns only groups that have been added to the app as well.
     *                  Skips corporations that are not found in the local database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCorpGroupsBulkV1Request
*/
func (a *ApplicationGroupsApiService) CorpGroupsBulkV1(ctx context.Context) ApiCorpGroupsBulkV1Request {
	return ApiCorpGroupsBulkV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Corporation
func (a *ApplicationGroupsApiService) CorpGroupsBulkV1Execute(r ApiCorpGroupsBulkV1Request) ([]Corporation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Corporation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.CorpGroupsBulkV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v1/corp-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCorpGroupsV1Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	cid int32
}

func (r ApiCorpGroupsV1Request) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.CorpGroupsV1Execute(r)
}

/*
CorpGroupsV1 Return groups of the corporation.

Needs role: app-groups.<br>Returns only groups that have been added to the app as well.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cid EVE corporation ID.
 @return ApiCorpGroupsV1Request

Deprecated
*/
func (a *ApplicationGroupsApiService) CorpGroupsV1(ctx context.Context, cid int32) ApiCorpGroupsV1Request {
	return ApiCorpGroupsV1Request{
		ApiService: a,
		ctx: ctx,
		cid: cid,
	}
}

// Execute executes the request
//  @return []Group
// Deprecated
func (a *ApplicationGroupsApiService) CorpGroupsV1Execute(r ApiCorpGroupsV1Request) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.CorpGroupsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v1/corp-groups/{cid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCorpGroupsV2Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	cid int32
}

func (r ApiCorpGroupsV2Request) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.CorpGroupsV2Execute(r)
}

/*
CorpGroupsV2 Return groups of the corporation.

Needs role: app-groups.<br>Returns only groups that have been added to the app as well.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cid EVE corporation ID.
 @return ApiCorpGroupsV2Request
*/
func (a *ApplicationGroupsApiService) CorpGroupsV2(ctx context.Context, cid int32) ApiCorpGroupsV2Request {
	return ApiCorpGroupsV2Request{
		ApiService: a,
		ctx: ctx,
		cid: cid,
	}
}

// Execute executes the request
//  @return []Group
func (a *ApplicationGroupsApiService) CorpGroupsV2Execute(r ApiCorpGroupsV2Request) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.CorpGroupsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v2/corp-groups/{cid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupMembersV1Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	groupId int32
	corporation *int32
}

// Limit to characters that are a member of this corporation.
func (r ApiGroupMembersV1Request) Corporation(corporation int32) ApiGroupMembersV1Request {
	r.corporation = &corporation
	return r
}

func (r ApiGroupMembersV1Request) Execute() ([]int32, *http.Response, error) {
	return r.ApiService.GroupMembersV1Execute(r)
}

/*
GroupMembersV1 Returns the main character IDs from all group members.

Needs role: app-groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Group ID.
 @return ApiGroupMembersV1Request
*/
func (a *ApplicationGroupsApiService) GroupMembersV1(ctx context.Context, groupId int32) ApiGroupMembersV1Request {
	return ApiGroupMembersV1Request{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []int32
func (a *ApplicationGroupsApiService) GroupMembersV1Execute(r ApiGroupMembersV1Request) ([]int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.GroupMembersV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v1/group-members/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterToString(r.groupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.corporation != nil {
		localVarQueryParams.Add("corporation", parameterToString(*r.corporation, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsBulkV1Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	requestBody *[]int32
}

// EVE character IDs array.
func (r ApiGroupsBulkV1Request) RequestBody(requestBody []int32) ApiGroupsBulkV1Request {
	r.requestBody = &requestBody
	return r
}

func (r ApiGroupsBulkV1Request) Execute() ([]CharacterGroups, *http.Response, error) {
	return r.ApiService.GroupsBulkV1Execute(r)
}

/*
GroupsBulkV1 Return groups of multiple players, identified by one of their character IDs.

Needs role: app-groups.<br>
     *                  Returns only groups that have been added to the app as well.
     *                  Skips characters that are not found in the local database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsBulkV1Request
*/
func (a *ApplicationGroupsApiService) GroupsBulkV1(ctx context.Context) ApiGroupsBulkV1Request {
	return ApiGroupsBulkV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CharacterGroups
func (a *ApplicationGroupsApiService) GroupsBulkV1Execute(r ApiGroupsBulkV1Request) ([]CharacterGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CharacterGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.GroupsBulkV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v1/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsV1Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	cid int32
}

func (r ApiGroupsV1Request) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.GroupsV1Execute(r)
}

/*
GroupsV1 Return groups of the character's player account.

Needs role: app-groups.<br>Returns only groups that have been added to the app as well.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cid EVE character ID.
 @return ApiGroupsV1Request

Deprecated
*/
func (a *ApplicationGroupsApiService) GroupsV1(ctx context.Context, cid int32) ApiGroupsV1Request {
	return ApiGroupsV1Request{
		ApiService: a,
		ctx: ctx,
		cid: cid,
	}
}

// Execute executes the request
//  @return []Group
// Deprecated
func (a *ApplicationGroupsApiService) GroupsV1Execute(r ApiGroupsV1Request) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.GroupsV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v1/groups/{cid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsV2Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	cid int32
}

func (r ApiGroupsV2Request) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.GroupsV2Execute(r)
}

/*
GroupsV2 Return groups of the character's player account.

Needs role: app-groups.<br>Returns only groups that have been added to the app as well.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cid EVE character ID.
 @return ApiGroupsV2Request
*/
func (a *ApplicationGroupsApiService) GroupsV2(ctx context.Context, cid int32) ApiGroupsV2Request {
	return ApiGroupsV2Request{
		ApiService: a,
		ctx: ctx,
		cid: cid,
	}
}

// Execute executes the request
//  @return []Group
func (a *ApplicationGroupsApiService) GroupsV2Execute(r ApiGroupsV2Request) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.GroupsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v2/groups/{cid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cid"+"}", url.PathEscape(parameterToString(r.cid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGroupsWithFallbackV1Request struct {
	ctx context.Context
	ApiService *ApplicationGroupsApiService
	character *int32
	corporation *int32
	alliance *int32
}

// EVE character ID.
func (r ApiGroupsWithFallbackV1Request) Character(character int32) ApiGroupsWithFallbackV1Request {
	r.character = &character
	return r
}

// EVE corporation ID.
func (r ApiGroupsWithFallbackV1Request) Corporation(corporation int32) ApiGroupsWithFallbackV1Request {
	r.corporation = &corporation
	return r
}

// EVE alliance ID.
func (r ApiGroupsWithFallbackV1Request) Alliance(alliance int32) ApiGroupsWithFallbackV1Request {
	r.alliance = &alliance
	return r
}

func (r ApiGroupsWithFallbackV1Request) Execute() ([]Group, *http.Response, error) {
	return r.ApiService.GroupsWithFallbackV1Execute(r)
}

/*
GroupsWithFallbackV1 Returns groups from the character's account, if available, or the corporation and alliance.

Needs role: app-groups.<br>
     *                  Returns only groups that have been added to the app as well.<br>
     *                  It is not checked if character, corporation and alliance match.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGroupsWithFallbackV1Request
*/
func (a *ApplicationGroupsApiService) GroupsWithFallbackV1(ctx context.Context) ApiGroupsWithFallbackV1Request {
	return ApiGroupsWithFallbackV1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Group
func (a *ApplicationGroupsApiService) GroupsWithFallbackV1Execute(r ApiGroupsWithFallbackV1Request) ([]Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationGroupsApiService.GroupsWithFallbackV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/app/v1/groups-with-fallback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.character == nil {
		return localVarReturnValue, nil, reportError("character is required and must be specified")
	}
	if r.corporation == nil {
		return localVarReturnValue, nil, reportError("corporation is required and must be specified")
	}

	localVarQueryParams.Add("character", parameterToString(*r.character, ""))
	localVarQueryParams.Add("corporation", parameterToString(*r.corporation, ""))
	if r.alliance != nil {
		localVarQueryParams.Add("alliance", parameterToString(*r.alliance, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
